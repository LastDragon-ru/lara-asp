# Source:
# * https://github.com/micromatch/picomatch (bf6a33bd3db990edfbfd20b3b160eed926cd07dd)
# * picomatch/test/posix-classes.js

# describe('stars', () => {
## describe('issue related', () => {
### it('should respect dots defined in glob pattern (micromatch/#23)', () => {
  [true, "z.js", "z*"]
  [false, "zzjs", "z*.js"]
  [false, "zzjs", "*z.js"]

## describe('single stars', () => {
### it('should match anything except slashes and leading dots', () => {
  [false, "a/b/c/z.js", "*.js"]
  [false, "a/b/z.js", "*.js"]
  [false, "a/z.js", "*.js"]
  [true, "z.js", "*.js"]

  [false, "a/.ab", "*/*"]
  [false, ".ab", "*"]

  [true, "z.js", "z*.js"]
  [true, "a/z", "*/*"]
  [true, "a/z.js", "*/z*.js"]
  [true, "a/z.js", "a/z*.js"]

  [true, "ab", "*"]
  [true, "abc", "*"]

  [false, "bar", "f*"]
  [false, "foo", "*r"]
  [false, "foo", "b*"]
  [false, "foo/bar", "*"]
  [true, "abc", "*c"]
  [true, "abc", "a*"]
  [true, "abc", "a*c"]
  [true, "bar", "*r"]
  [true, "bar", "b*"]
  [true, "foo", "f*"]

### it('should match spaces', () => {
  [true, "one abc two", "*abc*"]
  [true, "a         b", "a*b"]

### it('should support multiple non-consecutive stars in a path segment', () => {
  [false, "foo", "*a*"]
  [true, "bar", "*a*"]
  [true, "oneabctwo", "*abc*"]
  [false, "a-b.c-d", "*-bc-*"]
  [true, "a-b.c-d", "*-*.*-*"]
  [true, "a-b.c-d", "*-b*c-*"]
  [true, "a-b.c-d", "*-b.c-*"]
  [true, "a-b.c-d", "*.*"]
  [true, "a-b.c-d", "*.*-*"]
  [true, "a-b.c-d", "*.*-d"]
  [true, "a-b.c-d", "*.c-*"]
  [true, "a-b.c-d", "*b.*d"]
  [true, "a-b.c-d", "a*.c*"]
  [true, "a-b.c-d", "a-*.*-d"]
  [true, "a.b", "*.*"]
  [true, "a.b", "*.b"]
  [true, "a.b", "a.*"]
  [true, "a.b", "a.b"]

### it('should support multiple stars in a segment', () => {
  [false, "a-b.c-d", "**-bc-**"]
  [true, "a-b.c-d", "**-**.**-**"]
  [true, "a-b.c-d", "**-b**c-**"]
  [true, "a-b.c-d", "**-b.c-**"]
  [true, "a-b.c-d", "**.**"]
  [true, "a-b.c-d", "**.**-**"]
  [true, "a-b.c-d", "**.**-d"]
  [true, "a-b.c-d", "**.c-**"]
  [true, "a-b.c-d", "**b.**d"]
  [true, "a-b.c-d", "a**.c**"]
  [true, "a-b.c-d", "a-**.**-d"]
  [true, "a.b", "**.**"]
  [true, "a.b", "**.b"]
  [true, "a.b", "a.**"]
  [true, "a.b", "a.b"]

### it('should return true when one of the given patterns matches the string', () => {
  [true, "/ab", "*/*"]
  [true, ".", "."]
  [false, "a/.b", "a/"]
  [true, "/ab", "/*"]
  [true, "/ab", "/??"]
  [true, "/ab", "/?b"]
  [true, "/cd", "/*"]
  [true, "a", "a"]
  [true, "a/.b", "a/.*"]
  [true, "a/b", "?/?"]
  [true, "a/b/c/d/e/j/n/p/o/z/c.md", "a/**/j/**/z/*.md"]
  [true, "a/b/c/d/e/z/c.md", "a/**/z/*.md"]
  [true, "a/b/c/xyz.md", "a/b/c/*.md"]
  [true, "a/b/c/xyz.md", "a/b/c/*.md"]
  [true, "a/b/z/.a", "a/*/z/.a"]
  [false, "a/b/z/.a", "bz"]
  [true, "a/bb.bb/aa/b.b/aa/c/xyz.md", "a/**/c/*.md"]
  [true, "a/bb.bb/aa/bb/aa/c/xyz.md", "a/**/c/*.md"]
  [true, "a/bb.bb/c/xyz.md", "a/*/c/*.md"]
  [true, "a/bb/c/xyz.md", "a/*/c/*.md"]
  [true, "a/bbbb/c/xyz.md", "a/*/c/*.md"]
  [true, "aaa", "*"]
  [true, "ab", "*"]
  [true, "ab", "ab"]

### it('should return false when the path does not match the pattern', () => {
  [false, "/ab", "*/"]
  [false, "/ab", "*/a"]
  [false, "/ab", "/"]
  [false, "/ab", "/?"]
  [false, "/ab", "/a"]
  [false, "/ab", "?/?"]
  [false, "/ab", "a/*"]
  [false, "a/.b", "a/"]
  [false, "a/b/c", "a/*"]
  [false, "a/b/c", "a/b"]
  [false, "a/b/c/d/e/z/c.md", "b/c/d/e"]
  [false, "a/b/z/.a", "b/z"]
  [false, "ab", "*/*"]
  [false, "ab", "/a"]
  [false, "ab", "a"]
  [false, "ab", "b"]
  [false, "ab", "c"]
  [false, "abcd", "ab"]
  [false, "abcd", "bc"]
  [false, "abcd", "c"]
  [false, "abcd", "cd"]
  [false, "abcd", "d"]
  [false, "abcd", "f"]
  [false, "ef", "/*"]

### it('should match a path segment for each single star', () => {
  [false, "aaa", "*/*/*"]
  [false, "aaa/bb/aa/rr", "*/*/*"]
  [false, "aaa/bba/ccc", "aaa*"]
  [false, "aaa/bba/ccc", "aaa**"]
  [false, "aaa/bba/ccc", "aaa/*"]
  [false, "aaa/bba/ccc", "aaa/*ccc"]
  [false, "aaa/bba/ccc", "aaa/*z"]
  [false, "aaa/bbb", "*/*/*"]
  [false, "ab/zzz/ejkl/hi", "*/*jk*/*i"]
  [true, "aaa/bba/ccc", "*/*/*"]
  [true, "aaa/bba/ccc", "aaa/**"]
  [true, "aaa/bbb", "aaa/*"]
  [true, "ab/zzz/ejkl/hi", "*/*z*/*/*i"]
  [true, "abzzzejklhi", "*j*i"]

### it('should support single globs (*)', () => {
  [true, "a", "*"]
  [true, "b", "*"]
  [false, "a/a", "*"]
  [false, "a/a/a", "*"]
  [false, "a/a/b", "*"]
  [false, "a/a/a/a", "*"]
  [false, "a/a/a/a/a", "*"]

  [false, "a", "*/*"]
  [true, "a/a", "*/*"]
  [false, "a/a/a", "*/*"]

  [false, "a", "*/*/*"]
  [false, "a/a", "*/*/*"]
  [true, "a/a/a", "*/*/*"]
  [false, "a/a/a/a", "*/*/*"]

  [false, "a", "*/*/*/*"]
  [false, "a/a", "*/*/*/*"]
  [false, "a/a/a", "*/*/*/*"]
  [true, "a/a/a/a", "*/*/*/*"]
  [false, "a/a/a/a/a", "*/*/*/*"]

  [false, "a", "*/*/*/*/*"]
  [false, "a/a", "*/*/*/*/*"]
  [false, "a/a/a", "*/*/*/*/*"]
  [false, "a/a/b", "*/*/*/*/*"]
  [false, "a/a/a/a", "*/*/*/*/*"]
  [true, "a/a/a/a/a", "*/*/*/*/*"]
  [false, "a/a/a/a/a/a", "*/*/*/*/*"]

  [false, "a", "a/*"]
  [true, "a/a", "a/*"]
  [false, "a/a/a", "a/*"]
  [false, "a/a/a/a", "a/*"]
  [false, "a/a/a/a/a", "a/*"]

  [false, "a", "a/*/*"]
  [false, "a/a", "a/*/*"]
  [true, "a/a/a", "a/*/*"]
  [false, "b/a/a", "a/*/*"]
  [false, "a/a/a/a", "a/*/*"]
  [false, "a/a/a/a/a", "a/*/*"]

  [false, "a", "a/*/*/*"]
  [false, "a/a", "a/*/*/*"]
  [false, "a/a/a", "a/*/*/*"]
  [true, "a/a/a/a", "a/*/*/*"]
  [false, "a/a/a/a/a", "a/*/*/*"]

  [false, "a", "a/*/*/*/*"]
  [false, "a/a", "a/*/*/*/*"]
  [false, "a/a/a", "a/*/*/*/*"]
  [false, "a/a/b", "a/*/*/*/*"]
  [false, "a/a/a/a", "a/*/*/*/*"]
  [true, "a/a/a/a/a", "a/*/*/*/*"]

  [false, "a", "a/*/a"]
  [false, "a/a", "a/*/a"]
  [true, "a/a/a", "a/*/a"]
  [false, "a/a/b", "a/*/a"]
  [false, "a/a/a/a", "a/*/a"]
  [false, "a/a/a/a/a", "a/*/a"]

  [false, "a", "a/*/b"]
  [false, "a/a", "a/*/b"]
  [false, "a/a/a", "a/*/b"]
  [true, "a/a/b", "a/*/b"]
  [false, "a/a/a/a", "a/*/b"]
  [false, "a/a/a/a/a", "a/*/b"]

### it('should only match a single folder per star when globstars are used', () => {
  [false, "a", "*/**/a"]
  [false, "a/a/b", "*/**/a"]
  [true, "a/a", "*/**/a"]
  [true, "a/a/a", "*/**/a"]
  [true, "a/a/a/a", "*/**/a"]
  [true, "a/a/a/a/a", "*/**/a"]

### it('should not match a trailing slash when a star is last char', () => {
  [false, "a", "*/"]
  [false, "a", "*/*"]
  [false, "a", "a/*"]
  [false, "a/", "*/*"]
  [false, "a/", "a/*"]
  [false, "a/a", "*"]
  [false, "a/a", "*/"]
  [false, "a/x/y", "*/"]
  [false, "a/x/y", "*/*"]
  [false, "a/x/y", "a/*"]
  [false, "a/", "*", null, { "strictSlashes": true }]
  // (4.2) [true, "a/", "*"]
  [true, "a", "*"]
  [true, "a/", "*/"]
  // (1) [true, "a/", "*{,/}"]
  [true, "a/a", "*/*"]
  [true, "a/a", "a/*"]

### it('should work with file extensions', () => {
  [false, "a.txt", "a/**/*.txt"]
  [true, "a/x/y.txt", "a/**/*.txt"]
  [false, "a/x/y/z", "a/**/*.txt"]

  [false, "a.txt", "a/*.txt"]
  [true, "a/b.txt", "a/*.txt"]
  [false, "a/x/y.txt", "a/*.txt"]
  [false, "a/x/y/z", "a/*.txt"]

  [true, "a.txt", "a*.txt"]
  [false, "a/b.txt", "a*.txt"]
  [false, "a/x/y.txt", "a*.txt"]
  [false, "a/x/y/z", "a*.txt"]

  [true, "a.txt", "*.txt"]
  [false, "a/b.txt", "*.txt"]
  [false, "a/x/y.txt", "*.txt"]
  [false, "a/x/y/z", "*.txt"]

### it('should not match slashes when globstars are not exclusive in a path segment', () => {
  [false, "foo/baz/bar", "foo**bar"]
  [true, "foobazbar", "foo**bar"]

### it('should match slashes when defined in braces', () => {
  // (1) [true, "foo", "foo{,/**}"]

### it('should correctly match slashes', () => {
  [false, "a/b", "a*"]
  [false, "a/a/bb", "a/**/b"]
  [false, "a/bb", "a/**/b"]

  [false, "foo", "*/**"]
  [false, "foo/bar", "**/"]
  [false, "foo/bar", "**/*/"]
  [false, "foo/bar", "*/*/"]
  [false, "foo/bar/", "**/*", null, { "strictSlashes": true }]

  [true, "/home/foo/..", "**/.."]
  [true, "a", "**/a"]
  [true, "a/a", "**"]
  [true, "a/a", "a/**"]
  [true, "a/", "a/**"]
  // (4.2) [true, "a", "a/**"]
  [false, "a/a", "**/"]
  // (4.2) [true, "a", "**/a/**"]
  // (4.2) [true, "a", "a/**"]
  [false, "a/a", "**/"]
  [true, "a/a", "*/**/a"]
  // (4.2) [true, "a", "a/**"]
  [true, "foo/", "*/**"]
  [true, "foo/bar", "**/*"]
  [true, "foo/bar", "*/*"]
  [true, "foo/bar", "*/**"]
  [true, "foo/bar/", "**/"]
  // (4.2) [true, "foo/bar/", "**/*"]
  [true, "foo/bar/", "**/*/"]
  [true, "foo/bar/", "*/**"]
  [true, "foo/bar/", "*/*/"]

  [false, "bar/baz/foo", "*/foo"]
  [false, "deep/foo/bar", "**/bar/*"]
  [false, "deep/foo/bar/baz/x", "*/bar/**"]
  [false, "ef", "/*"]
  [false, "foo/bar", "foo?bar"]
  [false, "foo/bar/baz", "**/bar*"]
  [false, "foo/bar/baz", "**/bar**"]
  [false, "foo/baz/bar", "foo**bar"]
  [false, "foo/baz/bar", "foo*bar"]
  // (4.2) [true, "foo", "foo/**"]
  [true, "/ab", "/*"]
  [true, "/cd", "/*"]
  [true, "/ef", "/*"]
  [true, "a/b/j/c/z/x.md", "a/**/j/**/z/*.md"]
  [true, "a/j/z/x.md", "a/**/j/**/z/*.md"]

  [true, "bar/baz/foo", "**/foo"]
  [true, "deep/foo/bar/baz", "**/bar/*"]
  [true, "deep/foo/bar/baz/", "**/bar/**"]
  [true, "deep/foo/bar/baz/x", "**/bar/*/*"]
  [true, "foo/b/a/z/bar", "foo/**/**/bar"]
  [true, "foo/b/a/z/bar", "foo/**/bar"]
  [true, "foo/bar", "foo/**/**/bar"]
  [true, "foo/bar", "foo/**/bar"]
  [true, "foo/bar/baz/x", "*/bar/**"]
  [true, "foo/baz/bar", "foo/**/**/bar"]
  [true, "foo/baz/bar", "foo/**/bar"]
  [true, "XXX/foo", "**/foo"]

### it('should ignore leading \"./\" when defined on pattern', () => {
  // (4.2) [true, "ab", "./*"]
  [false, "ab", "./*/"]
  // (4.2) [true, "ab/", "./*/"]

### it('should optionally match trailing slashes with braces', () => {
  [true, "foo", "**/*"]
  // (1) [true, "foo", "**/*{,/}"]
  // (1) [true, "foo/", "**/*{,/}"]
  // (1) [true, "foo/bar", "**/*{,/}"]
  // (1) [true, "foo/bar/", "**/*{,/}"]
