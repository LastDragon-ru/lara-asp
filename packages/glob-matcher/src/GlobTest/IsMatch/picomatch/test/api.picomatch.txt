# Source:
# * https://github.com/micromatch/picomatch (bf6a33bd3db990edfbfd20b3b160eed926cd07dd)
# * test/api.picomatch.js

# describe('picomatch', () => {

## describe('file extensions', () => {
### it('should match files that contain the given extension:', () => {
  [false, ".c.md", "*.md"]
  [false, ".c.md", ".c."]
  [false, ".c.md", ".md"]
  [false, ".md", "*.md"]
  [false, ".md", ".m"]
  [false, "a/b/c.md", "*.md"]
  [false, "a/b/c.md", ".md"]
  [false, "a/b/c.md", "a/*.md"]
  [false, "a/b/c/c.md", "*.md"]
  [false, "a/b/c/c.md", "c.js"]
  [true, ".c.md", ".*.md"]
  [true, ".md", ".md"]
  [true, "a/b/c.js", "a/**/*.*"]
  [true, "a/b/c.md", "**/*.md"]
  [true, "a/b/c.md", "a/*/*.md"]
  [true, "c.md", "*.md"]

## describe('dot files', () => {
### it('should not match dotfiles when a leading dot is not defined in a path segment', () => {
  [false, ".a", "(a)*"]
  [false, ".a", "*(a|b)"]
  [false, ".a", "*.md"]
  [false, ".a", "*[a]"]
  [false, ".a", "*[a]*"]
  [false, ".a", "*a"]
  [false, ".a", "*a*"]
  [false, ".a.md", "a/b/c/*.md"]
  [false, ".ab", "*.*"]
  [false, ".abc", ".a"]
  [false, ".ba", ".a"]
  [false, ".c.md", "*.md"]
  [false, ".md", "a/b/c/*.md"]
  [false, ".txt", ".md"]
  [false, ".verb.txt", "*.md"]
  [false, "a/.c.md", "*.md"]
  [false, "a/b/d/.md", "a/b/c/*.md"]
  [true, ".a", ".a"]
  [true, ".ab", ".*"]
  [true, ".ab", ".a*"]
  [true, ".b", ".b*"]
  [true, ".md", ".md"]
  [true, "a/.c.md", "a/.c.md"]
  [true, "a/b/c/.xyz.md", "a/b/c/.*.md"]
  [true, "a/b/c/d.a.md", "a/b/c/*.md"]

### it('should match dotfiles when options.dot is true', () => {
  [false, "a/b/c/.xyz.md", ".*.md", { "hidden": true }]
  [true, ".c.md", "*.md", { "hidden": true }]
  [true, ".c.md", ".*", { "hidden": true }]
  [true, "a/b/c/.xyz.md", "**/*.md", { "hidden": true }]
  [true, "a/b/c/.xyz.md", "**/.*.md", { "hidden": true }]
  [true, "a/b/c/.xyz.md", "a/b/c/*.md", { "hidden": true }]
  [true, "a/b/c/.xyz.md", "a/b/c/.*.md", { "hidden": true }]

## describe('matching:', () => {
### it('should escape plus signs to match string literals', () => {
  [true, "a+b/src/glimini.js", "a+b/src/*.js"]
  [true, "+b/src/glimini.js", "+b/src/*.js"]
  [true, "coffee+/src/glimini.js", "coffee+/src/*.js"]
  [true, "coffee+/src/glimini.js", "coffee+/src/*"]

### it('should match with non-glob patterns', () => {
  [true, ".", "."]
  [true, "/a", "/a"]
  [false, "/ab", "/a"]
  [true, "a", "a"]
  [false, "ab", "/a"]
  [false, "ab", "a"]
  [true, "ab", "ab"]
  [false, "abcd", "cd"]
  [false, "abcd", "bc"]
  [false, "abcd", "ab"]

### it('should match file names', () => {
  [true, "a.b", "a.b"]
  [true, "a.b", "*.b"]
  [true, "a.b", "a.*"]
  [true, "a.b", "*.*"]
  [true, "a-b.c-d", "a*.c*"]
  [true, "a-b.c-d", "*b.*d"]
  [true, "a-b.c-d", "*.*"]
  [true, "a-b.c-d", "*.*-*"]
  [true, "a-b.c-d", "*-*.*-*"]
  [true, "a-b.c-d", "*.c-*"]
  [true, "a-b.c-d", "*.*-d"]
  [true, "a-b.c-d", "a-*.*-d"]
  [true, "a-b.c-d", "*-b.c-*"]
  [true, "a-b.c-d", "*-b*c-*"]
  [false, "a-b.c-d", "*-bc-*"]

### it('should match with common glob patterns', () => {
  [false, "/ab", "./*/"]
  [false, "/ef", "*"]
  [false, "ab", "./*/"]
  [false, "ef", "/*"]
  [true, "/ab", "/*"]
  [true, "/cd", "/*"]
  [true, "ab", "*"]
  // (4.1) [true, "ab", "./*"]
  [true, "ab", "ab"]
  // (4.1) [true, "ab/", "./*/"]

### it('should match files with the given extension', () => {
  [false, ".md", "*.md"]
  [true, ".md", ".md"]
  [false, ".c.md", "*.md"]
  [true, ".c.md", ".*.md"]
  [true, "c.md", "*.md"]
  [true, "c.md", "*.md"]
  [false, "a/b/c/c.md", "*.md"]
  [false, "a/b/c.md", "a/*.md"]
  [true, "a/b/c.md", "a/*/*.md"]
  [true, "a/b/c.md", "**/*.md"]
  [true, "a/b/c.js", "a/**/*.*"]

### it('should match wildcards', () => {
  [false, "a/b/c/z.js", "*.js"]
  [false, "a/b/z.js", "*.js"]
  [false, "a/z.js", "*.js"]
  [true, "z.js", "*.js"]

  [true, "z.js", "z*.js"]
  [true, "a/z.js", "a/z*.js"]
  [true, "a/z.js", "*/z*.js"]

### it('should match globstars', () => {
  [true, "a/b/c/z.js", "**/*.js"]
  [true, "a/b/z.js", "**/*.js"]
  [true, "a/z.js", "**/*.js"]
  [true, "a/b/c/d/e/z.js", "a/b/**/*.js"]
  [true, "a/b/c/d/z.js", "a/b/**/*.js"]
  [true, "a/b/c/z.js", "a/b/c/**/*.js"]
  [true, "a/b/c/z.js", "a/b/c**/*.js"]
  [true, "a/b/c/z.js", "a/b/**/*.js"]
  [true, "a/b/z.js", "a/b/**/*.js"]

  [false, "a/z.js", "a/b/**/*.js"]
  [false, "z.js", "a/b/**/*.js"]

  // https://github.com/micromatch/micromatch/issues/15
  [true, "z.js", "z*"]
  [true, "z.js", "**/z*"]
  [true, "z.js", "**/z*.js"]
  [true, "z.js", "**/*.js"]
  [true, "foo", "**/foo"]

### it('issue #23', () => {
  [false, "zzjs", "z*.js"]
  [false, "zzjs", "*z.js"]

### it('issue #24 - should match zero or more directories', () => {
  [false, "a/b/c/d/", "a/b/**/f"]
  // (4.2) [true, "a", "a/**"]
  [true, "a", "**"]
  [true, "a/", "**"]
  [true, "a/b-c/d/e/z.js", "a/b-*/**/z.js"]
  [true, "a/b-c/z.js", "a/b-*/**/z.js"]
  [true, "a/b/c/d", "**"]
  [true, "a/b/c/d/", "**"]
  [true, "a/b/c/d/", "**/**"]
  [true, "a/b/c/d/", "**/b/**"]
  [true, "a/b/c/d/", "a/b/**"]
  [true, "a/b/c/d/", "a/b/**/"]
  [true, "a/b/c/d/", "a/b/**/c/**/"]
  [true, "a/b/c/d/", "a/b/**/c/**/d/"]
  [true, "a/b/c/d/e.f", "a/b/**/**/*.*"]
  [true, "a/b/c/d/e.f", "a/b/**/*.*"]
  [true, "a/b/c/d/e.f", "a/b/**/c/**/d/*.*"]
  [true, "a/b/c/d/e.f", "a/b/**/d/**/*.*"]
  [true, "a/b/c/d/g/e.f", "a/b/**/d/**/*.*"]
  [true, "a/b/c/d/g/g/e.f", "a/b/**/d/**/*.*"]

### it('should match slashes', () => {
  [false, "bar/baz/foo", "*/foo"]
  [false, "deep/foo/bar", "**/bar/*"]
  [false, "deep/foo/bar/baz/x", "*/bar/**"]
  [false, "foo/bar", "foo?bar"]
  [false, "foo/bar/baz", "**/bar*"]
  [false, "foo/bar/baz", "**/bar**"]
  [false, "foo/baz/bar", "foo**bar"]
  [false, "foo/baz/bar", "foo*bar"]
  [false, "deep/foo/bar/baz", "**/bar/*/"]
  [false, "deep/foo/bar/baz/", "**/bar/*", null, { "strictSlashes": true }]
  // (4.2) [true, "deep/foo/bar/baz/", "**/bar/*"]
  [true, "deep/foo/bar/baz", "**/bar/*"]
  // (4.2) [true, "foo", "foo/**"]
  // (1) [true, "deep/foo/bar/baz/", "**/bar/*{,/}"]
  [true, "a/b/j/c/z/x.md", "a/**/j/**/z/*.md"]
  [true, "a/j/z/x.md", "a/**/j/**/z/*.md"]
  [true, "bar/baz/foo", "**/foo"]
  [true, "deep/foo/bar/", "**/bar/**"]
  [true, "deep/foo/bar/baz", "**/bar/*"]
  [true, "deep/foo/bar/baz/", "**/bar/*/"]
  [true, "deep/foo/bar/baz/", "**/bar/**"]
  [true, "deep/foo/bar/baz/x", "**/bar/*/*"]
  [true, "foo/b/a/z/bar", "foo/**/**/bar"]
  [true, "foo/b/a/z/bar", "foo/**/bar"]
  [true, "foo/bar", "foo/**/**/bar"]
  [true, "foo/bar", "foo/**/bar"]
  // (4.7) [true, "foo/bar", "foo[/]bar"]
  [true, "foo/bar/baz/x", "*/bar/**"]
  [true, "foo/baz/bar", "foo/**/**/bar"]
  [true, "foo/baz/bar", "foo/**/bar"]
  [true, "foobazbar", "foo**bar"]
  [true, "XXX/foo", "**/foo"]

  // https://github.com/micromatch/micromatch/issues/89
  [true, "foo//baz.md", "foo//baz.md"]
  [true, "foo//baz.md", "foo//*baz.md"]
  // (1) [true, "foo//baz.md", "foo{/,//}baz.md"]
  // (1) [true, "foo/baz.md", "foo{/,//}baz.md"]
  [false, "foo//baz.md", "foo/+baz.md"]
  [false, "foo//baz.md", "foo//+baz.md"]
  [false, "foo//baz.md", "foo/baz.md"]
  [false, "foo/baz.md", "foo//baz.md"]

### it('question marks should not match slashes', () => {
  [false, "aaa/bbb", "aaa?bbb"]

### it('should not match dotfiles when `dot` or `dotfiles` are not set', () => {
  [false, ".c.md", "*.md"]
  [false, "a/.c.md", "*.md"]
  [true, "a/.c.md", "a/.c.md"]
  [false, ".a", "*.md"]
  [false, ".verb.txt", "*.md"]
  [true, "a/b/c/.xyz.md", "a/b/c/.*.md"]
  [true, ".md", ".md"]
  [false, ".txt", ".md"]
  [true, ".md", ".md"]
  [true, ".a", ".a"]
  [true, ".b", ".b*"]
  [true, ".ab", ".a*"]
  [true, ".ab", ".*"]
  [false, ".ab", "*.*"]
  [false, ".md", "a/b/c/*.md"]
  [false, ".a.md", "a/b/c/*.md"]
  [true, "a/b/c/d.a.md", "a/b/c/*.md"]
  [false, "a/b/d/.md", "a/b/c/*.md"]

### it('should match dotfiles when `dot` or `dotfiles` is set', () => {
  [true, ".c.md", "*.md", { "hidden": true }]
  [true, ".c.md", ".*", { "hidden": true }]
  [true, "a/b/c/.xyz.md", "a/b/c/*.md", { "hidden": true }]
  [true, "a/b/c/.xyz.md", "a/b/c/.*.md", { "hidden": true }]
